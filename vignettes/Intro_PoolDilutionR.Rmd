---
title: "Introduction to PoolDilutionR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Intro_PoolDilutionR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
options(rmarkdown.html_vignette.check_title = FALSE)

knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## What is Pool Dilution?

Pool dilution is an isotope tracer technique wherein a biogeochemical pool is artificially enriched with its heavy isotopologue. After enrichment, the gross production and consumption rates of that pool can be calculated using the change in isotopic signature and absolute pool size over time. This technique can be applied to many different chemical species and was originally developed to measure soil nutrient transformations (Kirkham and Bartholomew 1954).  \


```{r setup, include=FALSE}
library(PoolDilutionR)
library(dplyr)
library(ggplot2)
library(ggpmisc)
library(tidyr)
library(kableExtra)

theme_set(theme_minimal() + theme(text = element_text(size = 11)))
```

## PoolDilutionR (PDR)

PDR uses equations originally published in von Fischer and Hedin 2002, 10.1029/2001GB001448, with some modifications. The strength of this method is that the equations take into account the effect of isotopic fractionation (see Fractionation below).  
\
**Worked Example**\
Below are 5 data points collected during a methane pool dilution experiment for one soil sample.  
Data source, Morris et al, *in prep*.  \
\
Key to columns:

|    time_days: vector of time between samples in days  
|    cal12CH4ml: mL's of 12C methane, calculated from incubation volume and sample ppm  
|    cal13CH4ml: mL's of 13C methane, calculated from incubation volume and sample ppm  
|    AP_obs: percent of methane that is 13C methane, 13C/(12C + 13C) * 100  
```{r Input Data, message = FALSE}
Morris2023 %>%
  filter(id == "71") %>%
  select(-"id") %>%
  kbl(caption = "Data for Sample #71")
```

## Solving for gross rates

To solve for gross methane production and consumption for this sample, we call pdr_optimize(), which uses optim() to minimize the error in the observed vs predicted pool size and isotopic composition. Errors are weighted by a  combination of data quality and explanitory power (see cost_fuction()) and predictions are made using ap_prediction().\
\
\
From von Fischer and Hedin 2002\
\
$$
AP_t = \frac{n_0^{-k\alpha t}}{\frac{P}{k}-(\,\frac{P}{k}-m_0)^{-kt}\,}
$$

$$
\alpha = \frac{k_{(\,^{13}C)\,}}{k_{(\,^{12}C)\,}}
$$
\
Where:\
$k_{(\,^{13}C)\,}$ is the first-order rate constant for consumption of 13CH4\
and\
$k_{(\,^{12}C)\,}$ is the first-order rate constant for consumption of 12CH4\
\
```{r Solve for P and k}
Morris2023 %>% filter(id == "71") -> OneSample_dat

OneSampleResult <- list()

OneSample <- pdr_optimize(time = OneSample_dat$time_days, #time as a vector
                          m = OneSample_dat$cal12CH4ml + OneSample_dat$cal13CH4ml, #total pool size
                          n = OneSample_dat$cal13CH4ml,#pool size of heavy isotopologue
                          P = 0.1, #inital production rate for optim()
                          pool = "CH4", #indicates using the default fractionation rates of methane
                          m_prec = 0.001, #instrument precision for total pool size, as standard deviation
                          ap_prec = 1, #instrument precision for atom percent, as standard deviation
                          include_progress = FALSE)

P <- OneSample$par["P"]
OneSampleResult <- tibble(P = P,
                          k = OneSample$par["k"],
                          k0 = OneSample$initial_par["k"],
                          convergence = OneSample$convergence,
                          message = OneSample$message)
```
**Output**
```{r}
OneSampleResult %>%
  mutate_if(is.numeric, format, digits=4) %>%
  kbl(caption = "Optimized P and k")
```

## Variations with pdr_optimize()
  
Feeding data from the following samples results in fits of different quality.  
```{r Example Data, echo = FALSE, message = TRUE, out.width = c("100%", "300px")}
facet_labels <- c(
    AP_obs = "Atom% Observed",
    cal12CH4ml = "12C Methane (mL)",
    cal13CH4ml = "13C Methane (mL)")

Morris2023 %>%
    mutate(sample_id = as.factor(id)) %>%
    pivot_longer(cols = c(cal12CH4ml, cal13CH4ml, AP_obs)) %>%
    ggplot(aes(time_days, value,
               group = sample_id, color = sample_id)) +
    scale_color_discrete("Sample ID") +
    geom_point() + geom_line() + ylab("") + xlab("\n Timestep (d)") +
    ggtitle("Example Input Data") +
    facet_wrap(~name, scales = "free_y",
                labeller = labeller(name = facet_labels)) +
    theme(axis.text.x = element_text(angle = 45, hjust = 0.75)) -> input_data
print(input_data)
```

```{r Do the thing!, echo=TRUE, message = FALSE, warning = FALSE, results='hide'}
pk_results <- list()
incdat_out <- list()
all_predictions <- list()

for(i in unique(Morris2023$id)) {
    message("------------------- ", i)
    # Isolate this sample's data
    Morris2023 %>%
        filter(id == i) %>%
        select(id, time_days,
               cal12CH4ml, cal13CH4ml,
               AP_obs) ->
        dat
    
result <- pdr_optimize(time = dat$time_days,
                          m = dat$cal12CH4ml + dat$cal13CH4ml,
                          n = dat$cal13CH4ml,
                          P = 0.1,
                          pool = "CH4",
                          m_prec = 0.001,
                          ap_prec = 1,
                          include_progress = TRUE)
    
    # Save progress details separately so they don't print below
    progress_detail <- result$progress
    result$progress <- NULL

    P <- result$par["P"]
    pk_results[[i]] <- tibble(P = P,
                              k = result$par["k"],
                              k0 = result$initial_par["k"],
                              convergence = result$convergence,
                              message = result$message)
    
    # Predict based on the optimized parameters
    pred <- ap_prediction(time = dat$time_days,
                          m0 = dat$cal12CH4ml[1] + dat$cal13CH4ml[1],
                          n0 = dat$cal13CH4ml[1],
                          P = P,
                          k = result$par["k"],
                          pool = "CH4")
    dat <- bind_cols(dat, pred)
    
    # Predict based on ALL the models that were tried
    
    x <- split(progress_detail, seq_len(nrow(progress_detail)))
    all_preds <- lapply(x, FUN = function(x) {
      y1<- data.frame(P = x$P[1],
                      k = x$k[1],
                      time = seq(min(dat$time_days), max(dat$time_days), length.out = 20))
      y2 <- ap_prediction(time = y1$time,
                          m0 = dat$cal12CH4ml[1] + dat$cal13CH4ml[1],
                          n0 = dat$cal13CH4ml[1],
                          P = x$P[1],
                          k = x$k[1],
                          pool = "CH4")
      cbind(y1, y2)
    })
    all_predictions[[i]] <- bind_rows(all_preds)

    # Calculate implied consumption (ml) based on predictions
    # Equation 4: dm/dt = P - C, so C = P - dm/dt
    total_methane <- dat$cal12CH4ml + dat$cal13CH4ml
    change_methane <- c(0, diff(total_methane))
    change_time <- c(0, diff(dat$time_days))
    dat$Pt <- P * change_time #P is ml/day
    #amount of methane produced at time (t) of this incubation, a volume in mL
    dat$Ct <- dat$Pt - change_methane
    #amount of methane consumed at time (t) of this incubation, a volume in mL

    incdat_out[[i]] <- dat
}

pk_results <- bind_rows(pk_results, .id = "id")
incdat_out <- bind_rows(incdat_out)
all_predictions <- bind_rows(all_predictions, .id = "id")

incdat_out %>%
    # compute correlation between predictions and observations
    group_by(id) %>%
    summarise(m_cor = cor(cal12CH4ml + cal13CH4ml, mt),
              ap_cor = cor(AP_obs, AP_pred)) ->
    performance_summary

performance_summary %>%
    right_join(pk_results, by = "id") ->
    pk_results
print(pk_results)

pk_results %>%
    right_join(incdat_out, by = "id") ->
    incdat_out
```

```{r echo = FALSE}
# ----- Plot AP results -----
incdat_out %>%
  ggplot(aes(time_days, AP_obs, color = as.factor(id))) +
  geom_point(aes(shape = ""), size = 3.75) +
  geom_line(data = filter(all_predictions),
            aes(time, AP_pred, group = paste(id, P, k)), color = "grey", linetype = 2) +
  geom_line(aes(y = AP_pred, group = id, linetype = ""),
            linewidth = 1.25) +
  scale_linetype_manual(name = "Prediction",
                        values = "dotted") +
  scale_shape_manual(name = "Observations",
                     values = 20) +
  scale_color_discrete(guide = "none") +
  facet_wrap(~as.numeric(id), scales = "free") +
  xlab("\n Timestep \n") + ylab("\n (13C-CH4/Total CH4) x 100 \n") +
  ggtitle("\n Atom% 13C \n") + theme(legend.position = "bottom")


# ----- Plot total methane results -----
incdat_out %>%
  ggplot(aes(time_days, cal12CH4ml + cal13CH4ml, color = as.factor(id))) +
  geom_point(aes(shape = ""), size = 3.75) +
  geom_line(data = filter(all_predictions),
            aes(time, mt, group = paste(id, P, k)), color = "grey", linetype = 2) +
  geom_line(aes(y = mt, group = id, linetype = ""),
            linewidth = 1.25) +
  scale_linetype_manual(name = "Prediction",
                        values = "dotted") +
  scale_shape_manual(name = "Observations",
                     values = 20) +
  scale_color_discrete(guide = "none") +
  facet_wrap(~as.numeric(id), scales = "free") +
  xlab("\n Timestep \n") + ylab("\n Volume (mL) \n") +
  ggtitle("\n Total Methane \n") + theme(legend.position = "bottom")
```
```
## Cost Function
## Prediction
## Fractionation
